<html xmlns:th="http://www.thymeleaf.org">
<th:block th:fragment="template">
    <!--/*@thymesVar id="currentSession" type="easy.soc.hacks.frontend.domain.Session"*/-->

    <canvas id="mapCanvas">

    </canvas>
    <th:block th:include=":: collectAndShowMapScript"></th:block>
</th:block>

<th:block th:fragment="collectAndShowMapScript">
    <script th:inline="javascript">
        const xMin = -10
        const xMax = 10
        const yMin = -5
        const yMax = 5

        let nextBatchId = undefined

        let batchIdFrameIdPointsDict = {}
        let batchIdDurationDict = {}
        let readyToProcessBatchSet = new Set()

        const canvas = document.getElementById("mapCanvas")
        canvas.width = 600
        canvas.height = 300

        const context = canvas.getContext("2d")

        function clearCanvas() {
            context.clearRect(0, 0, canvas.width, canvas.height)
        }

        function isPointOnCanvas(point) {
            return (
                point[0] >= xMin && point[0] <= xMax &&
                point[1] >= yMin && point[1] <= yMax
            )
        }

        function drawPoint(x, y, radius) {
            if (isPointOnCanvas([x, y])) {
                const canvasX = (x - xMin) / (xMax - xMin) * canvas.width
                const canvasY = (y - yMin) / (yMax - yMin) * canvas.height
                const canvasRadius = radius / (xMax - xMin) * canvas.width

                context.beginPath()
                context.arc(canvasX, canvasY, canvasRadius, 0, 2 * Math.PI)
                context.fill()
            }
        }

        function drawFrame(resolve, batchId, frameId) {
            clearCanvas()

            for (let pointId in batchIdFrameIdPointsDict[batchId][frameId]) {
                const point = batchIdFrameIdPointsDict[batchId][frameId][pointId]

                const x = point[0]
                const y = point[1]
                const radius = point[2]

                drawPoint(x, y, radius)
            }

            resolve()
        }

        async function drawBatch(batchId) {
            const duration = batchIdDurationDict[batchId]

            let timeoutList = []

            for (let frameId in batchIdFrameIdPointsDict[batchId]) {
                timeoutList.push(new Promise((resolve) => setTimeout(
                    drawFrame,
                    frameId * (1000.0 * duration / Object.keys(batchIdFrameIdPointsDict[batchId]).length),
                    resolve,
                    batchId,
                    frameId
                )))
            }

            for (let timeoutId in timeoutList) {
                await timeoutList[timeoutId]
            }
        }

        let nextBatchToProcess = undefined

        async function processBatches() {
            if (readyToProcessBatchSet.has(nextBatchToProcess)) {
                readyToProcessBatchSet.delete(nextBatchToProcess)

                await drawBatch(nextBatchToProcess)

                delete batchIdFrameIdPointsDict[nextBatchToProcess]
                delete batchIdDurationDict[nextBatchToProcess]

                nextBatchToProcess++
            }

            setTimeout(processBatches, 0)
        }

        processBatches()

        function requestProjection() {
            const loadingGifXHR = new XMLHttpRequest()
            loadingGifXHR.open("GET", "/api/v1/session/projection")
            loadingGifXHR.responseType = "json"

            loadingGifXHR.onload = (event) => {
                if (event.target.status === 200) {
                    const response = event.target.response

                    const batchId = response["batchId"]
                    const duration = response["duration"]

                    if (nextBatchId === undefined || nextBatchId === batchId) {
                        if (nextBatchId === undefined) {
                            nextBatchToProcess = batchId
                        }

                        nextBatchId = batchId + 1

                        batchIdDurationDict[batchId] = duration
                        batchIdFrameIdPointsDict[batchId] = {}

                        for (let projectionId in response["projectionList"]) {
                            const projection = response["projectionList"][projectionId]

                            const frameId = projection["frameId"]
                            const x = projection["x"]
                            const y = projection["y"]
                            const radius = projection["radius"]

                            if (batchIdFrameIdPointsDict[batchId][frameId] === undefined) {
                                batchIdFrameIdPointsDict[batchId][frameId] = []
                            }

                            batchIdFrameIdPointsDict[batchId][frameId].push([x, y, radius])
                        }
                    }

                    readyToProcessBatchSet.add(batchId)
                } else {
                }
            }

            loadingGifXHR.send()
        }

        const videoIds = [[${videoList}]].map((video) => video.id)

        let existFragmentCount = 0
        function checkFragmentExists(videoId) {
            const checkFragmentExistsXHR = new XMLHttpRequest()
            checkFragmentExistsXHR.open("GET", "/api/v1/video/manifest/check?id=" + videoId)

            checkFragmentExistsXHR.onload = (event) => {
                if (event.target.status === 200 && event.target.response === "true") {
                    existFragmentCount++

                    if (existFragmentCount === videoIds.length) {
                        setInterval(
                            requestProjection,
                            1000
                        )
                    }
                } else if (event.target.status === 404) {
                } else {
                    setTimeout(checkFragmentExists, 1000, videoId)
                }
            }

            checkFragmentExistsXHR.send()
        }

        videoIds.forEach(videoId => {
            checkFragmentExists(videoId)
        })
    </script>
</th:block>