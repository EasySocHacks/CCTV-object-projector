<html xmlns:th="http://www.thymeleaf.org">
<th:block th:fragment="template">
    <!--/*@thymesVar id="currentSession" type="easy.soc.hacks.frontend.domain.Session"*/-->

    <canvas id="mapCanvas">

    </canvas>
    <th:block th:include=":: collectAndShowMapScript"></th:block>
</th:block>

<th:block th:fragment="collectAndShowMapScript">
    <script th:inline="javascript">
        const xMin = -5
        const xMax = 5
        const yMin = -5
        const yMax = 5

        const canvas = document.getElementById("mapCanvas")
        canvas.width = canvas.style.width
        canvas.height = canvas.style.height

        const context = canvas.getContext("2d")

        function clearCanvas() {
            context.clearRect(0, 0, canvas.width, canvas.height)
        }

        function isPointOnCanvas(point) {
            return (
                point[0] >= xMin && point[0] <= xMax &&
                point[1] >= yMin && point[1] <= yMax
            )
        }

        function requestProjection() {
            const loadingGifXHR = new XMLHttpRequest()
            loadingGifXHR.open("GET", "/api/v1/session/projection")
            loadingGifXHR.onload = (event) => {
                const batchProjections = event.target.response

                if (batchProjections.length > 0) {
                    let frameIdDict = {}

                    for (let projection in batchProjections) {
                        const frameId = projection["frameId"]
                        const x = parseFloat(projection["x"])
                        const y = parseFloat(projection["y"])
                        const radius = parseFloat(projection["radius"])

                        if (frameIdDict[frameId] === undefined) {
                            frameIdDict[frameId] = []
                        }

                        frameIdDict[frameId].push([x, y, radius])
                    }

                    clearCanvas()

                    for (let frameId in frameIdDict) {
                        for (let point in frameIdDict[frameId]) {
                            const x = point[0]
                            const y = point[1]
                            const radius = point[2]

                            console.log(
                                x,
                                y,
                                radius,
                                isPointOnCanvas([x, y]),
                                (x - xMin) / (xMax - xMin) * canvas.width,
                                (y - yMin) / (yMax - yMin) * canvas.height
                            )

                            if (isPointOnCanvas([x, y])) {
                                const canvasX = (x - xMin) / (xMax - xMin) * canvas.width
                                const canvasY = (y - yMin) / (yMax - yMin) * canvas.height

                                context.beginPath()
                                context.arc(canvasX, canvasY, 2, 0, 2 * Math.PI)
                                context.stroke()
                            }
                        }
                    }
                }
            }

            loadingGifXHR.send()
        }

        setInterval(
            requestProjection,
            1000
        )

        // draw()
        //
        // async function draw() {
        //     const points = new Map()
        //     const pointCount = 10
        //
        //     while (true) {
        //         context.clearRect(0, 0, width, height)
        //
        //         for (let i = 0; i < pointCount; i++) {
        //             if (!points.has(i)) {
        //                 points.set(i, [Math.random() * width, Math.random() * height, Math.random() * 2 - 1, Math.random() * 2 - 1])
        //             } else {
        //                 [x, y, vx, vy] = points.get(i)
        //
        //                 x += vx
        //                 y += vy
        //
        //                 if (x < -10 || x > width + 10 || y < -10 || y > height + 10) {
        //                     x = width - x
        //                     y = height - y
        //                 }
        //
        //                 points.set(i, [x, y, vx, vy])
        //             }
        //         }
        //
        //         for (let i = 0; i < pointCount; i++) {
        //             context.beginPath();
        //             [x, y, vx, vy] = points.get(i)
        //             context.arc(x, y, 2, 0, 2 * Math.PI)
        //             context.stroke()
        //         }
        //
        //         await new Promise(resolve => setTimeout(resolve, 1000 / 30))
        //     }
        // }
    </script>
</th:block>